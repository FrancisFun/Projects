# CMM-IDE
## 项目概述

本项目是CMM语言的集成开发环境（以下简称为CMM IDE），为CMM语言（即C语言精简版）提供代码编辑、编译、运行及调试的功能。

在词法分析、语法分析及语义分析的过程中，若出现了错误，CMM IDE将给出错误提示，用户也可结合语法树查看错误的位置。若无错误，CMM IDE将运行代码并输出结果。

为了便于用户对程序进行调试，用户可对代码中的某一行或多行打断点，并以调试模式执行，IDE将在断点处暂停程序，用户可查看此时的调用栈，并可选择Continue、Step into与Step over三种调试命令。



## 项目结构

CMM IDE解决方案内含有两个项目。CMMInterpreter是CMM解释器的核心部分。
IDE-UI是CMM IDE的界面部分。

具体项目结构如下所示。

```c#
├─CMMInterpreter        // CMM解释器项目
│  ├─antlr              // ANTLR自动生成部分(*)
│  ├─CMMException       // 错误异常
│  ├─debuger            // 调试器(*)
│  ├─g4                 // G4语法部分(*)
│  ├─inter              // 中间代码翻译部分
│  ├─util               // 哈希链表
│  └─vm                 // 虚拟机
│      ├─exception      // 虚拟机异常
├─IDE-UI                // IDE界面项目
│  ├─Asset              //资源文件
│  ├─Controls           // 控制类
│  ├─Converter          // 转换器
│  ├─DrawTreeGraph      // 语法树绘制
│  ├─Helper             // 帮助类
│  ├─Properties         // 属性文件
│  ├─Style              // 风格文件
│  └─test               // 测试代码文件
```

备注：`(*)`为本人负责部分，由于本项目主要作为实习参考使用，故下列只展示本人负责部分的所用技术、攻克难点、改进方向及参考材料。



## 所用技术

为了简化语法分析阶段的设计难度，我们决定采用生成器自动生成语法分析程序。而常用的生成器主要有Bison及ANTLR。

两者之间的区别主要有以下五点：

①语法与动作的分离与否，由于Bison的设计较为老旧，仅支持语法中嵌入动作来完成额外操作，产生的代码的可读性较差；而ANTLR则可以将语法和动作分离，提高了代码的可读性；同时，语法和动作的分离也提高了语法的可复用性；

②支持语法格式的不同，Bison仅支持BNF，BNF的语法更为繁杂且可读性较差，而ANTLR支持EBNF，EBNF的语法更为简洁也更为符合人类的阅读习惯；

③语法分析方法的不同，Bison支持两种语法解析方法，即LALR和GLR；ANTLR采用的语法分析方法为ALL(*)方法。LALR与ALL(*)相比解析速度更快但可解析的语言没有ALL(*)丰富；GLR与ALL(*)相比可解析的语言种类更多。尽管从理论上分析ALL(*)的时间复杂度为O(n4),GLR的时间复杂度为O(n3)，但从已有的实验数据上看，ALL(*)的解析速度比GLR更快；

④调试难度的不同，与ALL(*)相比GLR更不适合调试，因为ALL(*)方法是自顶向下进行分析的，与人类的常规逻辑较为符合；而GLR方法是自底向上进行分析的，较难进行错误的排查；

⑤解析器的代码量不同，Bison生成表驱动的解析器，处理逻辑包含在解析表中，而不是在解析器的代码中，因此产生的解析器代码占用空间也较小；而ANTLR生成递归下降解析器，处理逻辑包含在解析器中，因此产生的解析器代码占用空间也更大。

由于ANTLR具有诸多优势，本次项目中采用ANTLR生成器完成词法分析及语法分析，并使用ANTLR所提供的接口进行语义分析与中间代码生成。



## 攻克难点

在开始调试器的设计前，通过查阅资料，我发现有一种调试的实现方式是将调试功能绑定到虚拟机中，界面将断点列表直接传到虚拟机中。在调试模式下，虚拟机执行代码前首先判断当前中间代码的行号是否位于断点列表中，若位于则挂起虚拟机的线程，交由IDE界面进行处理。

虽然这种方式可以实现调试功能，但虚拟机承担了本是调试器所需要完成的功能，调试器与虚拟机的耦合性过高。

从软件开发的角度来说，调试器的开发者与虚拟机的开发者很可能不是同一个人甚至不是同一开发小组的人。如果采用这种调试器设计思路，调试器的开发者需要非常了解虚拟机的实现逻辑，才能实现调试器的功能。如要了解整个虚拟机执行中间代码的逻辑才能决定判断中间代码行号是否为断点行号的位置的逻辑应该写在虚拟机源代码的哪个区域中；需要了解虚拟机中出栈、入栈及栈帧结构与符号表的结构才能获取正确的调用栈信息，这些无疑增加了调试器开发者的工作压力与开发难度。

同时，由于调试器的实现高度依赖于虚拟机的实现，未来若需要更换虚拟机，则需要重新实现调试的逻辑，软件的可复用性较差。

基于上述原因，我在这次调试器设计中，采用了调试器与虚拟机分离的设计思路并采用了软中断机制。虚拟机只需要完成执行指令的功能即可，不需要知道断点在哪里，也不需要管理断点信息。同时，我还设计了一个虚拟机接口，将虚拟机抽象为接口。只要是实现该接口的虚拟机，调试器都可以对其进行调试，提高了调试器的可复用性，也便于未来对虚拟机进行改进与更换，提高了软件的可维护性。

接口具体描述如下表所示。

| 接口名                         | IVirtualMachine                                              |
| ------------------------------ | ------------------------------------------------------------ |
| 方法名                         | 备注                                                         |
| GetCurrentFrame                | 获取当前栈帧，返回当前栈帧信息，包括地址、变量名与变量值     |
| GetStackFrames                 | 获取调用栈信息，返回调用栈信息，包括函数名、函数入口行号与函数栈帧信息 |
| GetLastCodeInformation         | 获取刚执行完的指令信息，返回刚执行完的中间代码               |
| GetIntermediateCodeInformation | 获取源代码-中间代码信息，返回源代码-中间代码信息             |
| InterpretSingleInstruction     | 执行单条指令，传入要执行的中间代码，虚拟机执行该条中间代码   |
| ReplaceWithInt                 | 替换中间代码为int指令，传入要替换的中间代码的地址，返回被替换的原始中间代码 |
| Resume                         | 恢复中间代码，传入要恢复的中间代码地址与中间代码             |
| Run                            | 开始运行，用于开始调试                                       |
| Stop                           | 停止运行，用于停止调试                                       |
| Load                           | 装载中间代码，传入中间代码序列                               |
| LoadDebugInformation           | 装载调试信息，传入全局符号表与函数信息表，用于调试时打印栈帧使用 |
| SetDebugHandler                | 设置调试处理器，用于处理调试事件                             |
| SetReadHandler                 | 设置读入处理器，用于处理输入事件                             |
| SetFinishHandler               | 设置结束处理器，用于处理调试结束事件                         |
| RegisterWindowListener         | 设置窗口监听器，用于处理输出事件                             |

在进行调试器的设计过程中，我参考了x86的软中断机制。

在真实的计算机环境中，调试的实现主要有两种选择，一种是硬中断，一种是软中断。

CPU有一个单独的执行序列，会逐条指令地顺序执行。要处理类似IO或者硬件时钟这样的异步事件时CPU就要用到中断。

硬件中断通常是一个专门的电信号，连接到一个特殊的“响应电路”上。这个电路会感知中断的到来，然后会使CPU停止当前的执行流，保存当前的状态，然后跳转到一个预定义的地址处去执行，这个地址上会有一个中断处理例程。当中断处理例程完成它的工作后，CPU就从之前停止的地方恢复执行。

软中断的原理类似，但实际上有一点不同。CPU支持特殊的指令，允许通过软件来模拟一个中断。当执行到这个指令时，CPU将其当作一个中断——停止当前正常的执行流，保存状态然后跳转到一个处理例程中执行。这种“陷阱”让许多现代的操作系统得以有效完成很多复杂任务（任务调度、虚拟内存、内存保护、调试等），而在x86中这条特殊指令就是int 3[4]。在我们本次项目的指令设计中也设计了这么一条i指令用于中断程序的执行并跳转到特定的调试程序中。

当调试开始后，调试器首先获取由中间代码生成器提供的全局变量表、函数信息表与中间代码，对这些数据进行处理，由中间代码与函数信息表生成源代码-中间代码表，并将全局变量表与函数信息表作为调试信息加载到虚拟机中。

随后，根据IDE提供的断点行号信息，结合中间代码与源代码-中间代码表对中间代码序列进行保存并替换操作，将行号与原始中间代码保存到行号-原始中间代码表中。

然后，将替换后的中间代码装载到虚拟机中，虚拟机开始单条执行中间代码，当遇到i指令时，虚拟机调用调试处理器事件，此事件绑定到调试器的HandleInterrupt方法，此方法会挂起调试线程，并调用调试器的调试处理器事件，此事件绑定到IDE的HandleDebug方法中，IDE可在此方法中获取当前的断点行号与调用栈，并在调试面板中显示这些信息，供用户进行排错与调试。

当用户输入调试指令后，IDE恢复调试器线程，调试器对用户输入调试指令进行解析，当用户输入stop指令（即停止调试指令）时，调试结束；否则调试器执行指令保存并替换操作，虚拟机恢复执行代码。



## 改进方向

现阶段只实现了Continue、Step into与Step over三种调试命令，未来还可以增加更多样的调试命令如Step out、逐中间指令执行等，便于用户进行调试。



## 参考资料

[1] Sword-Destiny. CMMParser [DB/OL]. Github, https://github.com/Sword-Destiny/CMMParser.2016-03-10.

[2] 小二黑. 调试器工作原理（2）：实现断点[EB/OL]. 博客园, https://www.cnblogs.com/xiaoerhei/p/4460285.html. 2015-04-27.

